#!/usr/bin/python3

#
# Copyright (C) 2025 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-2.0-only
#

import os
import re
import sys
import json
import subprocess
import argparse
from euci import EUci
from nethsec import utils

out_dir = "/etc/ha"

def disable_interfaces(file):
    u = EUci()
    with open(os.path.join(out_dir, file), 'r') as f:
        interfaces = json.load(f)
    for interface in interfaces.keys():
        u.set('network', interface, 'disabled', '1')
    u.commit('network')

def disable_routes():
    u = EUci()
    with open(os.path.join(out_dir, 'routes'), 'r') as f:
        routes = json.load(f)
    for route in routes.keys():
        u.set('network', route, 'disabled', '1')
    u.commit('network')

def disable_hotspot():
    u = EUci()
    devices = utils.get_all_by_type(u, 'network', 'device')
    for d in devices:
        device = devices[d]
        tags = device.get('ns_tag', [])
        if 'ha' in tags and device.get('ns_macaddr'):
            # Get the original MAC address using ethtool
            result = subprocess.run(["ethtool", "-P", device.get('name')], capture_output=True, text=True)
            for line in result.stdout.splitlines():
                if "Permanent address:" in line:
                    original_mac = line.split("Permanent address:")[1].strip()
                    break
            else:
                original_mac = ""
            if original_mac:
                # Set the original MAC address on the device
                subprocess.run(["ip", "link", "set", "dev", device.get('name'), "address", original_mac], check=True)

def stop_services():
    services = set()
    exceptions = {'nginx', 'dropbear'}
    hotplug_dir = "/etc/hotplug.d/keepalived"
    try:
        for fname in sorted(os.listdir(hotplug_dir)):
            path = os.path.join(hotplug_dir, fname)
            if not os.path.isfile(path):
                continue
            try:
                with open(path, 'r') as fh:
                    for line in fh:
                        # match: set_service_name <name>  (allow optional quotes)
                        m = re.search(r'\bset_service_name\s+([\'"]?)([A-Za-z0-9._-]+)\1', line)
                        if m and m.group(2) not in exceptions:
                            services.add(m.group(2))
            except Exception:
                # ignore unreadable files
                continue
    except Exception:
        # directory may not exist or be unreadable
        return

    for svc in services:
        init_script = os.path.join("/etc/init.d", svc)
        if os.path.exists(init_script) and os.path.isfile(init_script):
            try:
                subprocess.run([init_script, "stop"], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            except Exception:
                # ignore failures
                pass

def stop_wan_interfaces():
    u = EUci()
    try:
        wan_interfaces = u.get_all('firewall', 'ns_wan', 'network')
    except Exception:
        wan_interfaces = {}
    for interface in wan_interfaces:
         subprocess.run(["ifdown", interface], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

if __name__ == "__main__":
	# Parse --force flag to override HA role check
	parser = argparse.ArgumentParser(add_help=False)
	parser.add_argument("--force", action="store_true", help="Run disable actions regardless of HA role")
	args, _ = parser.parse_known_args()

	if not args.force:
		# Execute only on backup node (preserve previous behavior)
		try:
			proc = subprocess.run(["/usr/libexec/rpcd/ns.ha", "call", "status"], capture_output=True, text=True, check=True)
			status = json.loads(proc.stdout)
		except Exception:
			# If we can't determine role, be conservative and exit
			status = {}
		if status.get("role") != "backup":
			sys.exit(0)
	# If --force is provided, skip the role check and proceed
	disable_interfaces('wg_interfaces')
	disable_interfaces('ipsec_interfaces')
	disable_interfaces('wan_interfaces')
	disable_routes()
	disable_hotspot()
	if not args.force:
		# Apply the configuration changes
		subprocess.run(["/sbin/reload_config"], capture_output=True)
	else:
		# Tear down everything immediately in case of fault or stop
		stop_services()
		stop_wan_interfaces()
