#!/usr/bin/python3

#
# Copyright (C) 2025 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-2.0-only
#

from euci import EUci
from requests import HTTPError
from requests.auth import HTTPBasicAuth
import hashlib
import requests
import nethsec.utils
import json
import subprocess
import logging
from logging.handlers import SysLogHandler

FLASHSTART_API_ENDPOINT = 'https://api.flashstart.com/1.0.0'

DEFAULT_HEADERS = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
}

CONST_PORT_START = 5300

e_uci = EUci()
logger = logging.getLogger('ns-flashstart')
logger.setLevel(logging.INFO)


def __get_client() -> requests.Session:
    session = requests.Session()
    session.headers.update(DEFAULT_HEADERS)
    username = e_uci.get('flashstart', 'global', 'username', default='')
    password = e_uci.get('flashstart', 'global', 'password', default='')
    hashed_password = hashlib.md5(password.encode()).hexdigest()
    session.auth = HTTPBasicAuth(username, hashed_password)
    return session


def check_credentials(username, password):
    response = requests.post(f'{FLASHSTART_API_ENDPOINT}/auth/check/', auth=HTTPBasicAuth(username, password),
                             data='{"who": "Device"}',
                             headers=DEFAULT_HEADERS)
    response.raise_for_status()


def enable():
    # check if the cron entry already exists
    result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    cron_jobs = result.stdout.splitlines()

    flashstart_sync = False
    flashstart_auth = False
    for job in cron_jobs:
        if 'ns-flashstart sync' in job:
            flashstart_sync = True
        if 'flashstart-auth' in job:
            flashstart_auth = True

    if flashstart_sync:
        print('Flashstart sync already enabled, skipping.')
    else:
        # add the cron job
        subprocess.run(['bash', '-c',
                        '(crontab -l 2>/dev/null; echo \'* * * * * sleep $(( RANDOM % 30 )); /usr/sbin/ns-flashstart sync\') | crontab -'],
                       check=True)
        subprocess.run(['/usr/sbin/ns-flashstart', 'sync'], check=True)
        print('Flashstart sync enabled.')

    if flashstart_auth:
        print('Flashstart auth already enabled, skipping.')
    else:
        # add the cron job
        subprocess.run(['bash', '-c',
                        '(crontab -l 2>/dev/null; echo \'*/30 * * * * sleep $(( RANDOM % 60 )); /usr/share/ns-flashstart/flashstart-auth\') | crontab -'],
                       check=True)
        subprocess.run(['/usr/share/ns-flashstart/flashstart-auth'], check=True)
        print('Flashstart auth enabled.')


def disable():
    # check if the cron entry already exists
    result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    cron_jobs = result.stdout.splitlines()
    flashstart_sync = False
    flashstart_auth = False

    for job in cron_jobs:
        if 'ns-flashstart sync' in job:
            flashstart_sync = True
        if 'flashstart-auth' in job:
            flashstart_auth = True

    if flashstart_sync:
        # remove the cron job
        subprocess.run(['bash', '-c', '(crontab -l 2>/dev/null | grep -v \'ns-flashstart sync\') | crontab -'], check=True)
        logger.info('Flashstart sync disabled.')
    else:
        logger.info('Flashstart sync already disabled, skipping.')

    if flashstart_auth:
        # remove the cron job
        subprocess.run(['bash', '-c', '(crontab -l 2>/dev/null | grep -v \'flashstart-auth\') | crontab -'], check=True)
        logger.info('Flashstart auth disabled.')
    else:
        logger.info('Flashstart auth already disabled, skipping.')

    __redirect_teardown()


def sync_pro_plus_profiles():
    # check if changes to DHCP are pending
    dhcp_pending_changes = __check_pending_changes('dhcp')
    # generate the list of dnsmasq instances managed by flashstart
    local_instances = __fetch_local_instances()
    # fetch info from flashstart, and use just the first
    profiles = __get_profiles()
    # defaults
    port_start = CONST_PORT_START
    remote_instances = []
    # iterate over the profiles fetched from flashstart, deleting locally the instances not present in the list
    for profile in profiles:
        # generate reproducible instance id
        remote_instances.append(__add_profile(port_start, profile))
        port_start = port_start + 1

    # if the local instance is not present in the remote list, delete it
    for local_instance in local_instances:
        if local_instance not in remote_instances:
            logger.info(f'Profile {local_instance} not present in flashstart, deleting instance...')
            e_uci.delete('dhcp', local_instance)

    __save(dhcp_pending_changes, 'dhcp')


def __fetch_local_instances():
    # generate the list of dnsmasq instances managed by flashstart
    local_instances = []
    for dns in e_uci.get('dhcp', list=True, dtype=str, default=[]):
        if e_uci.get('dhcp', dns, 'ns_flashstart', default=None) is not None:
            local_instances.append(dns)
    return local_instances


def __get_profiles():
    client = __get_client()
    username = e_uci.get('flashstart', 'global', 'username', default='')
    response = client.get(f'{FLASHSTART_API_ENDPOINT}/network/profiles/{username}')
    response.raise_for_status()
    return response.json()


def __check_pending_changes(config: str):
    result = subprocess.run(['ubus', 'call', 'uci', 'changes', json.dumps({'config': config})], check=True,
                            capture_output=True, text=True)
    changes = json.loads(result.stdout)
    return 'changes' in changes and len(changes['changes']) > 0


def sync_host_sets():
    data = []
    for host_set in e_uci.get('objects', list=True, dtype=str, default=[]):
        if e_uci.get('objects', host_set) != 'host':
            continue
        data.append({
            'username': host_set,
            'name': e_uci.get('objects', host_set, 'name', default=''),
            'surname': ';'.join(e_uci.get('objects', host_set, 'ipaddr', default=[], dtype=str, list=True)),
        })
    client = __get_client()
    username = e_uci.get('flashstart', 'global', 'username', default='')
    response = client.post(f'{FLASHSTART_API_ENDPOINT}/sync/objects/{username}/1', json.dumps(data))
    response.raise_for_status()


def __add_profile(port: int, profile):
    profile_id = nethsec.utils.get_id(hashlib.sha256(profile['name'].encode()).hexdigest()[:10])
    if e_uci.get('dhcp', profile_id, default=None) is None:
        print(f'New profile found {profile["name"]}, creating instance {profile_id}.')
        # create the instance if it doesn't exist
        e_uci.set('dhcp', profile_id, 'dnsmasq')
        e_uci.set('dhcp', profile_id, 'ns_flashstart', True)
        e_uci.set('dhcp', profile_id, 'ns_flashstart_profile', profile['name'])
    # set the port, incrementing it for each profile
    if port != e_uci.get('dhcp', profile_id, 'port', default=None, dtype=int):
        e_uci.set('dhcp', profile_id, 'port', port)
    # since list assignment always replaces the list, we need to check if the lists are the same first
    # only replacing them if they are different
    dns_servers = [
        profile['dns']['ipv4']['primary_dns'],
        profile['dns']['ipv4']['secondary_dns']
    ]
    if list(e_uci.get('dhcp', profile_id, 'server', list=True, dtype=str, default=[])) != dns_servers:
        # set the dns servers
        e_uci.set('dhcp', profile_id, 'server', [
            profile['dns']['ipv4']['primary_dns'],
            profile['dns']['ipv4']['secondary_dns']
        ])
    return profile_id


def __save(pending_changes: bool, config: str):
    e_uci.save(config)
    changed = __check_pending_changes(config)
    if pending_changes:
        # don't commit if there are pending changes
        print(f'Some changes are pending to {config} configuration, skipping commit.')
    elif changed:
        # commit the changes to uci, this will trigger the dnsmasq reload
        print(f'Committing changes to {config} configuration.')
        subprocess.run(['ubus', 'call', 'uci', 'commit', json.dumps({'config': config})], check=True)


def sync_pro_profiles():
    # check if changes to DHCP are pending
    dhcp_pending_changes = __check_pending_changes('dhcp')
    # generate the list of dnsmasq instances managed by flashstart
    local_instances = __fetch_local_instances()
    # fetch info from flashstart, and use just the first
    profiles = __get_profiles()
    profile = profiles[0]
    # add profile
    profile_id = __add_profile(CONST_PORT_START, profile)
    # we're syncing a pro profile, delete every other entry
    for local_instance in local_instances:
        if local_instance != profile_id:
            e_uci.delete('dhcp', local_instance)

    __save(dhcp_pending_changes, 'dhcp')


def __redirect_teardown():
    for redirect_id in e_uci.get('firewall'):
        if e_uci.get('firewall', redirect_id) == 'redirect' and e_uci.get('firewall', redirect_id, 'ns_flashstart',
                                                                          default=False, dtype=bool):
            # delete the old interceptor
            # info(f'Deleting old interceptor {redirect}')
            e_uci.delete('firewall', redirect_id)


def setup_interceptors():
    firewall_pending_changes = __check_pending_changes('firewall')
    # prune old interceptors
    __redirect_teardown()
    # check if changes to firewall are pending
    if e_uci.get('flashstart', 'global', 'proplus', default=False, dtype=bool):
        raise NotImplementedError
    else:
        # debug('Enabling interceptors for PRO')
        for zone in e_uci.get('flashstart', 'global', 'zones', default=[], list=True):
            # if config is empty, skip, since we don't want to create an empty entry
            if zone == '':
                continue
            redirect_id = f'ns_flashstart_{zone}'
            e_uci.set('firewall', redirect_id, 'redirect')
            e_uci.set('firewall', redirect_id, 'name', f'Flashstart-intercept-DNS-from-{zone}')
            e_uci.set('firewall', redirect_id, 'src', zone)
            e_uci.set('firewall', redirect_id, 'src_dport', 53)
            e_uci.set('firewall', redirect_id, 'dest_port', CONST_PORT_START)
            e_uci.set('firewall', redirect_id, 'proto', "tcp udp")
            e_uci.set('firewall', redirect_id, 'target', 'DNAT')
            e_uci.set('firewall', redirect_id, 'ns_flashstart', True)

    __save(firewall_pending_changes, 'firewall')


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Nethesis Flashstart helper')
    parser.add_argument('--syslog', action='store_true', help='Print to syslog')
    subparsers = parser.add_subparsers(dest='command')

    check_credentials_parser = subparsers.add_parser('check-credentials', help='Util to check Flashstart credentials')
    check_credentials_parser.add_argument('--username', required=True)
    check_credentials_parser.add_argument('--password', required=True)

    subparsers.add_parser('sync', help='Sync Flashstart')
    subparsers.add_parser('enable', help='Enable the cron job for flashstart sync')
    subparsers.add_parser('disable', help='Disable the cron job for flashstart sync')

    args = parser.parse_args()
    if args.syslog:
        logger.addHandler(SysLogHandler())
    match args.command:
        case 'check-credentials':
            try:
                check_credentials(args.username, hashlib.md5(args.password.encode()).hexdigest())
                parser.exit(message='Credentials are valid.')
            except HTTPError as e:
                if e.response.status_code == 401:
                    parser.exit(1, message='Invalid credentials.')
                else:
                    parser.exit(1, message=f'Error checking credentials: {e}')
        case 'sync':
            pro_plus = e_uci.get('flashstart', 'global', 'proplus', default=False, dtype=bool)
            try:
                sync_host_sets()
                if pro_plus:
                    sync_pro_plus_profiles()
                else:
                    sync_pro_profiles()
            except HTTPError as e:
                parser.exit(1, message=f'Sync failed: {e}')
            except Exception as e:
                parser.exit(1, message=f'Unexpected error: {e}')
        case 'enable':
            enable()
        case 'disable':
            disable()
        case _:
            parser.print_help()

if __name__ == '__main__':
    main()
