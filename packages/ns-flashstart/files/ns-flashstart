#!/usr/bin/python3

#
# Copyright (C) 2025 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-2.0-only
#

from euci import EUci
from requests import HTTPError
from requests.auth import HTTPBasicAuth
import hashlib
import requests
import nethsec.utils
import json
import subprocess

FLASHSTART_API_ENDPOINT = 'https://api.flashstart.com/1.0.0'

DEFAULT_HEADERS = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
}


def __get_client(e_uci: EUci) -> requests.Session:
    session = requests.Session()
    session.headers.update(DEFAULT_HEADERS)
    username = e_uci.get('flashstart', 'global', 'username', default='')
    password = e_uci.get('flashstart', 'global', 'password', default='')
    hashed_password = hashlib.md5(password.encode()).hexdigest()
    session.auth = HTTPBasicAuth(username, hashed_password)
    return session


def check_credentials(username, password):
    response = requests.post(f'{FLASHSTART_API_ENDPOINT}/auth/check/', auth=HTTPBasicAuth(username, password),
                             data='{"who": "Device"}',
                             headers=DEFAULT_HEADERS)
    response.raise_for_status()


def enable():
    # check if the cron entry already exists
    result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    cron_jobs = result.stdout.splitlines()

    flashstart_sync = False
    flashstart_auth = False
    for job in cron_jobs:
        if 'ns-flashstart sync' in job:
            flashstart_sync = True
        if 'flashstart-auth' in job:
            flashstart_auth = True

    if flashstart_sync:
        print('Flashstart sync already enabled, skipping.')
    else:
        # add the cron job
        subprocess.run(['bash', '-c',
                        '(crontab -l 2>/dev/null; echo \'* * * * * sleep $(( RANDOM % 30 )); /usr/sbin/ns-flashstart sync\') | crontab -'],
                       check=True)
        subprocess.run(['/usr/sbin/ns-flashstart', 'sync'], check=True)
        print('Flashstart sync enabled.')

    if flashstart_auth:
        print('Flashstart auth already enabled, skipping.')
    else:
        # add the cron job
        subprocess.run(['bash', '-c',
                        '(crontab -l 2>/dev/null; echo \'*/30 * * * * sleep $(( RANDOM % 60 )); /usr/share/ns-flashstart/flashstart-auth\') | crontab -'],
                       check=True)
        subprocess.run(['/usr/share/ns-flashstart/flashstart-auth'], check=True)
        print('Flashstart auth enabled.')


def disable():
    # check if the cron entry already exists
    result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    cron_jobs = result.stdout.splitlines()
    flashstart_sync = False
    flashstart_auth = False

    for job in cron_jobs:
        if 'ns-flashstart sync' in job:
            flashstart_sync = True
        if 'flashstart-auth' in job:
            flashstart_auth = True

    if flashstart_sync:
        # remove the cron job
        subprocess.run(['bash', '-c', '(crontab -l 2>/dev/null | grep -v \'ns-flashstart sync\') | crontab -'], check=True)
        print('Flashstart sync disabled.')
    else:
        print('Flashstart sync already disabled, skipping.')

    if flashstart_auth:
        # remove the cron job
        subprocess.run(['bash', '-c', '(crontab -l 2>/dev/null | grep -v \'flashstart-auth\') | crontab -'], check=True)
        print('Flashstart auth disabled.')
    else:
        print('Flashstart auth already disabled, skipping.')


def sync_pro_plus(e_uci: EUci):
    # check if changes to DHCP are pending
    dhcp_pending_changes = __check_pending_changes('dhcp')
    # generate the list of dnsmasq instances managed by flashstart
    local_instances = __fetch_local_instances(e_uci)
    # fetch info from flashstart, and use just the first
    profiles = __get_profiles(e_uci)
    # defaults
    port_start = CONST_PORT_START
    remote_instances = []
    # iterate over the profiles fetched from flashstart, deleting locally the instances not present in the list
    for profile in profiles:
        # generate reproducible instance id
        remote_instances.append(__add_profile(e_uci, port_start, profile))
        port_start = port_start + 1

    # if the local instance is not present in the remote list, delete it
    for local_instance in local_instances:
        if local_instance not in remote_instances:
            print(f'Profile {local_instance} not present in flashstart, deleting instance...')
            e_uci.delete('dhcp', local_instance)

    __save(e_uci, dhcp_pending_changes)


def __fetch_local_instances(e_uci: EUci):
    # generate the list of dnsmasq instances managed by flashstart
    local_instances = []
    for dns in e_uci.get('dhcp', list=True, dtype=str, default=[]):
        if e_uci.get('dhcp', dns, 'ns_flashstart', default=None) is not None:
            local_instances.append(dns)
    return local_instances


def __get_profiles(e_uci: EUci):
    client = __get_client(e_uci)
    username = e_uci.get('flashstart', 'global', 'username', default='')
    response = client.get(f'{FLASHSTART_API_ENDPOINT}/network/profiles/{username}')
    response.raise_for_status()
    return response.json()


CONST_PORT_START = 5353


def __check_pending_changes(config: str):
    result = subprocess.run(['ubus', 'call', 'uci', 'changes', json.dumps({'config': config})], check=True,
                            capture_output=True, text=True)
    changes = json.loads(result.stdout)
    return 'changes' in changes and len(changes['changes']) > 0


def __add_profile(e_uci: EUci, port: int, profile):
    profile_id = nethsec.utils.get_id(hashlib.sha256(profile['name'].encode()).hexdigest()[:10])
    if e_uci.get('dhcp', profile_id, default=None) is None:
        print(f'New profile found {profile["name"]}, creating instance {profile_id}.')
        # create the instance if it doesn't exist
        e_uci.set('dhcp', profile_id, 'dnsmasq')
        e_uci.set('dhcp', profile_id, 'ns_flashstart', True)
        e_uci.set('dhcp', profile_id, 'ns_flashstart_profile', profile['name'])
    # set the port, incrementing it for each profile
    if port != e_uci.get('dhcp', profile_id, 'port', default=None, dtype=int):
        e_uci.set('dhcp', profile_id, 'port', port)
    # since list assignment always replaces the list, we need to check if the lists are the same first
    # only replacing them if they are different
    dns_servers = [
        profile['dns']['ipv4']['primary_dns'],
        profile['dns']['ipv4']['secondary_dns']
    ]
    if list(e_uci.get('dhcp', profile_id, 'server', list=True, dtype=str, default=[])) != dns_servers:
        # set the dns servers
        e_uci.set('dhcp', profile_id, 'server', [
            profile['dns']['ipv4']['primary_dns'],
            profile['dns']['ipv4']['secondary_dns']
        ])
    return profile_id


def __save(e_uci: EUci, pending_changes: bool):
    e_uci.save('dhcp')
    changed = __check_pending_changes('dhcp')
    if pending_changes:
        # don't commit if there are pending changes
        print('Some changes are pending to dhcp configuration, skipping commit.')
    elif changed:
        # commit the changes to uci, this will trigger the dnsmasq reload
        print('Committing changes to dhcp configuration.')
        subprocess.run(['ubus', 'call', 'uci', 'commit', json.dumps({'config': 'dhcp'})], check=True)


def sync_pro(e_uci: EUci):
    # check if changes to DHCP are pending
    dhcp_pending_changes = __check_pending_changes('dhcp')
    # generate the list of dnsmasq instances managed by flashstart
    local_instances = __fetch_local_instances(e_uci)
    # fetch info from flashstart, and use just the first
    profiles = __get_profiles(e_uci)
    profile = profiles[0]
    # add profile
    profile_id = __add_profile(e_uci, CONST_PORT_START, profile)
    # we're syncing a pro profile, delete every other entry
    for local_instance in local_instances:
        if local_instance != profile_id:
            e_uci.delete('dhcp', local_instance)

    __save(e_uci, dhcp_pending_changes)


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Nethesis Flashstart helper')
    parser.add_argument('--log-level', default='INFO', help='Set the log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)')
    subparsers = parser.add_subparsers(dest='command')

    check_credentials_parser = subparsers.add_parser('check-credentials', help='Util to check Flashstart credentials')
    check_credentials_parser.add_argument('--username', required=True)
    check_credentials_parser.add_argument('--password', required=True)

    sync_parser = subparsers.add_parser('sync', help='Sync Flashstart')
    sync_parser.add_argument('--pro-plus', action='store_true', help='Sync Flashstart PRO+ profiles')
    subparsers.add_parser('enable', help='Enable the cron job for flashstart sync')
    subparsers.add_parser('disable', help='Disable the cron job for flashstart sync')

    args = parser.parse_args()
    match args.command:
        case 'check-credentials':
            try:
                check_credentials(args.username, hashlib.md5(args.password.encode()).hexdigest())
                parser.exit(message='Credentials are valid.')
            except HTTPError as e:
                if e.response.status_code == 401:
                    parser.exit(1, message='Invalid credentials.')
                else:
                    parser.exit(1, message=f'Error checking credentials: {e}')
        case 'sync':
            e_uci = EUci()
            try:
                if args.pro_plus:
                    sync_pro_plus(e_uci)
                else:
                    sync_pro(e_uci)
            except HTTPError as e:
                parser.exit(1, message=f'Sync failed: {e}')
            except Exception as e:
                parser.exit(1, message=f'Unexpected error: {e}')
        case 'enable':
            enable()
        case 'disable':
            disable()
        case _:
            parser.print_help()

if __name__ == '__main__':
    main()
