#!/usr/bin/python3

#
# Copyright (C) 2025 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-2.0-only
#

from euci import EUci
from requests import HTTPError
from requests.auth import HTTPBasicAuth
import hashlib
import requests
import nethsec.utils
import json
import subprocess

FLASHSTART_API_ENDPOINT = 'https://api.flashstart.com/1.0.0'

DEFAULT_HEADERS = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
}


def __get_client(e_uci: EUci) -> requests.Session:
    session = requests.Session()
    session.headers.update(DEFAULT_HEADERS)
    username = e_uci.get('flashstart', 'global', 'username', default='')
    password = e_uci.get('flashstart', 'global', 'password', default='')
    hashed_password = hashlib.md5(password.encode()).hexdigest()
    session.auth = HTTPBasicAuth(username, hashed_password)
    return session


def check_credentials(username, password):
    response = requests.post(f'{FLASHSTART_API_ENDPOINT}/auth/check/', auth=HTTPBasicAuth(username, password),
                             data='{"who": "Device"}',
                             headers=DEFAULT_HEADERS)
    response.raise_for_status()


def enable():
    # check if the cron entry already exists
    result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    cron_jobs = result.stdout.splitlines()

    flashstart_sync = False
    flashstart_auth = False
    for job in cron_jobs:
        if 'ns-flashstart sync' in job:
            flashstart_sync = True
        if 'flashstart-auth' in job:
            flashstart_auth = True

    if flashstart_sync:
        print('Flashstart sync already enabled, skipping.')
    else:
        # add the cron job
        subprocess.run(['bash', '-c',
                        '(crontab -l 2>/dev/null; echo \'* * * * * sleep $(( RANDOM % 30 )); /usr/sbin/ns-flashstart sync\') | crontab -'],
                       check=True)
        subprocess.run(['/usr/sbin/ns-flashstart', 'sync'], check=True)
        print('Flashstart sync enabled.')

    if flashstart_auth:
        print('Flashstart auth already enabled, skipping.')
    else:
        # add the cron job
        subprocess.run(['bash', '-c',
                        '(crontab -l 2>/dev/null; echo \'*/30 * * * * sleep $(( RANDOM % 60 )); /usr/share/ns-flashstart/flashstart-auth\') | crontab -'],
                       check=True)
        subprocess.run(['/usr/share/ns-flashstart/flashstart-auth'], check=True)
        print('Flashstart auth enabled.')


def disable():
    # check if the cron entry already exists
    result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    cron_jobs = result.stdout.splitlines()
    flashstart_sync = False
    flashstart_auth = False

    for job in cron_jobs:
        if 'ns-flashstart sync' in job:
            flashstart_sync = True
        if 'flashstart-auth' in job:
            flashstart_auth = True

    if flashstart_sync:
        # remove the cron job
        subprocess.run(['bash', '-c', '(crontab -l 2>/dev/null | grep -v \'ns-flashstart sync\') | crontab -'], check=True)
        print('Flashstart sync disabled.')
    else:
        print('Flashstart sync already disabled, skipping.')

    if flashstart_auth:
        # remove the cron job
        subprocess.run(['bash', '-c', '(crontab -l 2>/dev/null | grep -v \'flashstart-auth\') | crontab -'], check=True)
        print('Flashstart auth disabled.')
    else:
        print('Flashstart auth already disabled, skipping.')


def sync(e_uci: EUci):
    changed = False
    # generate the list of dnsmasq instances managed by flashstart
    local_instances = []
    for dns in e_uci.get('dhcp', list=True, dtype=str, default=[]):
        if e_uci.get('dhcp', dns, 'ns_flashstart', default=None) is not None:
            local_instances.append(dns)

    # fetch info from flashstart
    client = __get_client(e_uci)
    username = e_uci.get('flashstart', 'global', 'username', default='')
    response = client.get(f'{FLASHSTART_API_ENDPOINT}/network/profiles/{username}')
    response.raise_for_status()
    data = response.json()
    # defaults
    port_start = 5353
    remote_instances = []
    # iterate over the profiles fetched from flashstart, deleting locally the instances not present in the list
    for profile in data:
        # generate reproducible instance id
        profile_id = nethsec.utils.get_id(hashlib.sha256(profile['name'].encode()).hexdigest()[:10])
        if e_uci.get('dhcp', profile_id, default=None) is None:
            print(f'New profile found {profile["name"]}, creating instance {profile_id}.')
            # create the instance if it doesn't exist
            e_uci.set('dhcp', profile_id, 'dnsmasq')
            e_uci.set('dhcp', profile_id, 'ns_flashstart', True)
            e_uci.set('dhcp', profile_id, 'ns_flashstart_profile', profile['name'])
            changed = True
        # set the port, incrementing it for each profile
        if port_start != e_uci.get('dhcp', profile_id, 'port', default=None, dtype=int):
            e_uci.set('dhcp', profile_id, 'port', port_start)
            changed = True
        port_start = port_start + 1

        # since list assignment always replaces the list, we need to check if the lists are the same first
        # only replacing them if they are different
        dns_servers = [
            profile['dns']['ipv4']['primary_dns'],
            profile['dns']['ipv4']['secondary_dns']
        ]
        if list(e_uci.get('dhcp', profile_id, 'server', list=True, dtype=str, default=[])) != dns_servers:
            # set the dns servers
            e_uci.set('dhcp', profile_id, 'server', [
                profile['dns']['ipv4']['primary_dns'],
                profile['dns']['ipv4']['secondary_dns']
            ])
            changed = True
        # save the id of the instance in the remote_ids list
        remote_instances.append(profile_id)

    # if the local instance is not present in the remote list, delete it
    for local_instance in local_instances:
        if local_instance not in remote_instances:
            print(f'Profile {local_instance} not present in flashstart, deleting instance...')
            e_uci.delete('dhcp', local_instance)
            changed = True

    if changed:
        # checking if any changes to dhcp have already been saved
        result = subprocess.run(['ubus', 'call', 'uci', 'changes', json.dumps({'config': 'dhcp'})], check=True,
                                capture_output=True, text=True)
        changes = json.loads(result.stdout)
        # saving the changes to uci
        e_uci.save('dhcp')
        # if there were changes to dhcp, we cannot commit
        if 'changes' in changes and len(changes['changes']) > 0:
            print('Some changes are pending to dhcp configuration, skipping commit.')
        else:
            # commit the changes to uci, this will trigger the dnsmasq reload
            subprocess.run(['ubus', 'call', 'uci', 'commit', json.dumps({'config': 'dhcp'})], check=True)


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Nethesis Flashstart helper')
    subparsers = parser.add_subparsers(dest='command')

    check_credentials_parser = subparsers.add_parser('check-credentials', help='Util to check Flashstart credentials')
    check_credentials_parser.add_argument('--username', required=True)
    check_credentials_parser.add_argument('--password', required=True)

    subparsers.add_parser('sync', help='Sync Flashstart profiles')
    subparsers.add_parser('enable', help='Enable the cron job for flashstart sync')
    subparsers.add_parser('disable', help='Disable the cron job for flashstart sync')

    args = parser.parse_args()
    match args.command:
        case 'check-credentials':
            try:
                check_credentials(args.username, hashlib.md5(args.password.encode()).hexdigest())
                parser.exit(message='Credentials are valid.')
            except HTTPError as e:
                if e.response.status_code == 401:
                    parser.exit(1, message='Invalid credentials.')
                else:
                    parser.exit(1, message=f'Error checking credentials: {e}')
        case 'sync':
            e_uci = EUci()
            try:
                sync(e_uci)
            except HTTPError as e:
                parser.exit(1, message=f'Sync failed: {e}')
            except Exception as e:
                parser.exit(1, message=f'Unexpected error: {e}')
        case 'enable':
            enable()
        case 'disable':
            disable()
        case _:
            parser.print_help()

if __name__ == '__main__':
    main()
