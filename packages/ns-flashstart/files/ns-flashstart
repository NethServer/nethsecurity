#!/usr/bin/python3

#
# Copyright (C) 2025 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-2.0-only
#

from euci import EUci
from requests import HTTPError
from requests.auth import HTTPBasicAuth
import hashlib
import requests
import nethsec.utils
import json
import subprocess
import logging
from logging.handlers import SysLogHandler

FLASHSTART_API_ENDPOINT = 'https://api.flashstart.com/1.0.0'

DEFAULT_HEADERS = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
}

CONST_PORT_START = 5300

e_uci = EUci()

def __get_client() -> requests.Session:
    session = requests.Session()
    session.headers.update(DEFAULT_HEADERS)
    username = e_uci.get('flashstart', 'global', 'username', default='')
    password = e_uci.get('flashstart', 'global', 'password', default='')
    hashed_password = hashlib.md5(password.encode()).hexdigest()
    session.auth = HTTPBasicAuth(username, hashed_password)
    return session


def check_credentials(username, password):
    response = requests.post(f'{FLASHSTART_API_ENDPOINT}/auth/check/', auth=HTTPBasicAuth(username, password),
                             data='{"who": "Device"}',
                             headers=DEFAULT_HEADERS)
    response.raise_for_status()


def enable():
    # check if the cron entry already exists
    result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    cron_jobs = result.stdout.splitlines()

    flashstart_sync = False
    flashstart_auth = False
    for job in cron_jobs:
        if 'ns-flashstart' in job:
            flashstart_sync = True
        if 'flashstart-auth' in job:
            flashstart_auth = True

    if flashstart_sync:
        logging.debug('Flashstart sync already enabled, skipping.')
    else:
        # add the cron job
        subprocess.run(['bash', '-c',
                        '(crontab -l 2>/dev/null; echo \'* * * * * sleep $(( RANDOM % 30 )); /usr/sbin/ns-flashstart --syslog sync\') | crontab -'],
                       check=True)
        subprocess.run(['/usr/sbin/ns-flashstart', 'sync'], check=True)
        logging.info('Flashstart sync enabled.')

    if flashstart_auth:
        logging.debug('Flashstart auth already enabled, skipping.')
    else:
        # add the cron job
        subprocess.run(['bash', '-c',
                        '(crontab -l 2>/dev/null; echo \'*/30 * * * * sleep $(( RANDOM % 60 )); /usr/share/ns-flashstart/flashstart-auth\') | crontab -'],
                       check=True)
        subprocess.run(['/usr/share/ns-flashstart/flashstart-auth'], check=True)
        logging.info('Flashstart auth enabled.')


def disable():
    # check if the cron entry already exists
    result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    cron_jobs = result.stdout.splitlines()
    flashstart_sync = False
    flashstart_auth = False

    for job in cron_jobs:
        if 'ns-flashstart' in job:
            flashstart_sync = True
        if 'flashstart-auth' in job:
            flashstart_auth = True

    if flashstart_sync:
        # remove the cron job
        subprocess.run(['bash', '-c', '(crontab -l 2>/dev/null | grep -v \'ns-flashstart\') | crontab -'], check=True)
        logging.info('Flashstart sync disabled.')
    else:
        logging.debug('Flashstart sync already disabled, skipping.')

    if flashstart_auth:
        # remove the cron job
        subprocess.run(['bash', '-c', '(crontab -l 2>/dev/null | grep -v \'flashstart-auth\') | crontab -'], check=True)
        logging.info('Flashstart auth disabled.')
    else:
        logging.debug('Flashstart auth already disabled, skipping.')

    for config in ['dhcp', 'firewall']:
        for entry in e_uci.get(config, list=True, dtype=str, default=[]):
            if e_uci.get(config, entry, 'ns_flashstart', default=False, dtype=bool):
                # delete the entry
                logging.debug(f'Deleting {config} entry {entry}')
                e_uci.delete(config, entry)
        e_uci.save(config)
        subprocess.run(['ubus', 'call', 'uci', 'commit', json.dumps({'config': config})], check=True)


def __fetch_local_dhcp_instances():
    # generate the list of dnsmasq instances managed by flashstart
    local_instances = []
    for dns in e_uci.get('dhcp', list=True, dtype=str, default=[]):
        if e_uci.get('dhcp', dns, 'ns_flashstart', default=None) is not None:
            local_instances.append(dns)
    return local_instances


def __fetch_local_redirect_instances():
    # generate the list of dns redirect for flashstart
    local_redirects = []
    for redirect in e_uci.get('firewall', list=True, dtype=str, default=[]):
        if e_uci.get('firewall', redirect) == 'redirect' and e_uci.get('firewall', redirect, 'ns_flashstart',
                                                                       default=False, dtype=bool):
            local_redirects.append(redirect)

    return local_redirects


def __check_pending_changes(config: str):
    result = subprocess.run(['ubus', 'call', 'uci', 'changes', json.dumps({'config': config})], check=True,
                            capture_output=True, text=True)
    changes = json.loads(result.stdout)
    return 'changes' in changes and len(changes['changes']) > 0


def __sync_host_sets():
    data = []
    for host_set in e_uci.get('objects', list=True, dtype=str, default=[]):
        if e_uci.get('objects', host_set) != 'host':
            continue
        data.append({
            'username': host_set,
            'name': e_uci.get('objects', host_set, 'name', default=''),
            'surname': ';'.join(e_uci.get('objects', host_set, 'ipaddr', default=[], dtype=str, list=True)),
        })
    client = __get_client()
    username = e_uci.get('flashstart', 'global', 'username', default='')
    response = client.post(f'{FLASHSTART_API_ENDPOINT}/sync/objects/{username}/1', json.dumps(data))
    response.raise_for_status()
    logging.info(f'Successfully synced {len(data)} host sets to flashstart.')


def __save(pending_changes: bool, config: str) -> bool:
    e_uci.save(config)
    changed = __check_pending_changes(config)
    if pending_changes:
        # don't commit if there are pending changes
        logging.warning(f'Some changes are pending to {config} configuration, skipping commit.')
    elif changed:
        # commit the changes to uci, this will trigger the dnsmasq reload
        logging.info(f'Committing changes to {config} configuration.')
        subprocess.run(['ubus', 'call', 'uci', 'commit', json.dumps({'config': config})], check=True)
        return True
    else:
        logging.debug(f'No changes to {config} configuration.')

    return False


def __sync_pro_profiles():
    # check if some changes are pending
    pending_changes = __check_pending_changes('dhcp') or __check_pending_changes('firewall')

    # get already existing dnsmasq instances managed by flashstart
    local_instances = __fetch_local_dhcp_instances()

    # fetch config
    config = __fetch_config()

    # use just the first, since we don't support multiple profiles in pro setup
    first_server = config['dhcp'][0]
    if e_uci.get('dhcp', first_server['id'], default=None) is None:
        logging.info(f'New profile found {first_server["name"]}, creating instance {first_server["id"]}.')
        e_uci.set('dhcp', first_server['id'], 'dnsmasq')
        e_uci.set('dhcp', first_server['id'], 'ns_flashstart', True)
        e_uci.set('dhcp', first_server['id'], 'ns_flashstart_profile', first_server["name"])
    e_uci.set('dhcp', first_server['id'], 'port', CONST_PORT_START)
    # sets always get replaced, checking before replacing
    if list(e_uci.get('dhcp', first_server['id'], 'server', list=True, dtype=str, default=[])) != first_server[
        'servers']:
        logging.debug(f'Replacing dns servers for {first_server["id"]} with {first_server["servers"]}')
        e_uci.set('dhcp', first_server['id'], 'server', first_server['servers'])
    # remove every other profile other than the first
    for local_instance in local_instances:
        if local_instance != first_server['id']:
            logging.info(f'Profile {local_instance} not present in flashstart, deleting instance...')
            e_uci.delete('dhcp', local_instance)

    # generate bypass firewall set
    if e_uci.get('firewall', 'ns_flashstart_bypass', default=None) is None:
        logging.debug(f'Creating bypass set for flashstart')
        # create the bypass set
        e_uci.set('firewall', 'ns_flashstart_bypass', 'ipset')
        e_uci.set('firewall', 'ns_flashstart_bypass', 'name', 'flashstart-bypass')
        e_uci.set('firewall', 'ns_flashstart_bypass', 'enabled', 1)
        e_uci.set('firewall', 'ns_flashstart_bypass', 'match', 'net')
        e_uci.set('firewall', 'ns_flashstart_bypass', 'family', 'inet')
        e_uci.set('firewall', 'ns_flashstart_bypass', 'ns_flashstart', True)
    # fetch the bypass list from flashstart
    bypass_list = [entry for entry in e_uci.get('flashstart', 'global', 'bypass', list=True, dtype=str, default=[])
                   if entry != '']
    # check if ipset entries are the same
    if list(e_uci.get('firewall', 'ns_flashstart_bypass', 'entry', list=True, dtype=str, default=[])) != bypass_list:
        e_uci.set('firewall', 'ns_flashstart_bypass', 'entry', bypass_list)

    # setup catch all DNAT rule for each zone
    local_redirects = __fetch_local_redirect_instances()
    applied_zones = []
    for zone in e_uci.get('flashstart', 'global', 'zones', default=[], list=True, dtype=str):
        redirect_id = f'ns_flashstart_{zone}'
        if e_uci.get('firewall', redirect_id, default=None) is None:
            # create the redirect if not present
            logging.debug(f'Creating new redirect {redirect_id}')
            e_uci.set('firewall', redirect_id, 'redirect')
            e_uci.set('firewall', redirect_id, 'name', f'Flashstart-intercept-DNS-from-{zone}')
            e_uci.set('firewall', redirect_id, 'src', zone)
            e_uci.set('firewall', redirect_id, 'src_dport', 53)
            e_uci.set('firewall', redirect_id, 'proto', "tcp udp")
            e_uci.set('firewall', redirect_id, 'target', 'DNAT')
            e_uci.set('firewall', redirect_id, 'ipset', f'!flashstart-bypass')
            e_uci.set('firewall', redirect_id, 'ns_flashstart', True)
        e_uci.set('firewall', redirect_id, 'dest_port', CONST_PORT_START)
        applied_zones.append(redirect_id)
    # remove every other redirect other than the ones in the list
    for local_redirect in local_redirects:
        if local_redirect not in applied_zones:
            logging.info(f'Redirect {local_redirect} not present in flashstart, deleting instance...')
            e_uci.delete('firewall', local_redirect)

    e_uci.save('dhcp')
    e_uci.save('firewall')
    if pending_changes:
        # don't commit if there are pending changes
        logging.warning('Some changes are pending to dhcp/firewall configuration, skipping commit.')
    elif __check_pending_changes('dhcp') or __check_pending_changes('firewall'):
        # commit the changes to uci, this will trigger all reloads
        logging.info(f'Applying changes to dhcp/firewall configuration.')
        subprocess.run(['ubus', 'call', 'uci', 'commit', json.dumps({'config': 'dhcp'})], check=True)
        subprocess.run(['ubus', 'call', 'uci', 'commit', json.dumps({'config': 'firewall'})], check=True)
        # workaround for the fact that ipset doesn't reload the sets on deletion
        subprocess.run(['fw4', 'reload-sets'])


def sync():
    __sync_host_sets()
    __sync_pro_profiles()


def __fetch_config():
    client = __get_client()
    username = e_uci.get('flashstart', 'global', 'username', default='')
    profiles = client.get(f'{FLASHSTART_API_ENDPOINT}/network/profiles/{username}')
    profiles.raise_for_status()
    data = {'dhcp': [], 'sessions': []}
    for profile in profiles.json():
        data['dhcp'].append({
            'id': nethsec.utils.get_id(hashlib.sha256(profile['name'].encode()).hexdigest()[:10]),
            'name': profile['name'],
            'catch-all': profile['is_catch-all'],
            'dns_code': profile['dns_code'],
            'servers': [
                profile['dns']['ipv4']['primary_dns'],
                profile['dns']['ipv4']['secondary_dns']
            ]
        })
    sessions = client.get(f'{FLASHSTART_API_ENDPOINT}/sessions/list/{username}')
    sessions.raise_for_status()
    for session in sessions.json():
        # if session.get('ip') is None:
        #     continue
        data['sessions'].append({
            'username': session['username'],
            'ip': session['ip'],
            'dns_code': session['dns_code']
        })

    return data


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Nethesis Flashstart helper')
    parser.add_argument('--log-level', default='info', choices=['debug', 'info', 'warning', 'error'],
                        help='Set the log level (default: info)')
    parser.add_argument('--syslog', action='store_true', help='Send logs to syslog')
    subparsers = parser.add_subparsers(dest='command')

    check_credentials_parser = subparsers.add_parser('check-credentials', help='Util to check Flashstart credentials')
    check_credentials_parser.add_argument('--username', required=True)
    check_credentials_parser.add_argument('--password', required=True)

    subparsers.add_parser('sync', help='Sync Flashstart')
    subparsers.add_parser('enable', help='Enable the cron job for flashstart sync')
    subparsers.add_parser('disable', help='Disable the cron job for flashstart sync')

    args = parser.parse_args()
    logger = logging.getLogger()
    logger.setLevel(getattr(logging, args.log_level.upper()))
    if args.syslog:
        handler = logging.handlers.SysLogHandler(facility=SysLogHandler.LOG_DAEMON, address='/dev/log')
        handler.setFormatter(logging.Formatter('ns-flashstart[%(process)d]: %(levelname)s - %(message)s'))
        logger.addHandler(handler)
    else:
        handler = logging.StreamHandler()
        logger.addHandler(handler)
    match args.command:
        case 'check-credentials':
            try:
                check_credentials(args.username, hashlib.md5(args.password.encode()).hexdigest())
                parser.exit(message='Credentials are valid.')
            except HTTPError as e:
                if e.response.status_code == 401:
                    parser.exit(1, message='Invalid credentials.')
                else:
                    parser.exit(1, message=f'Error checking credentials: {e}')
        case 'sync':
            try:
                sync()
            except HTTPError as e:
                logging.error(f'Error syncing profiles: {e}')
                parser.exit(1)
            except Exception as e:
                logging.error(f'Unexpected error: {e}')
                parser.exit(1)
        case 'enable':
            enable()
            sync()
        case 'disable':
            disable()
        case _:
            parser.print_help()

if __name__ == '__main__':
    main()
