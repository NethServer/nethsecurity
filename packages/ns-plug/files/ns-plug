#!/bin/bash

#
# Copyright (C) 2022 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-2.0-only
#

#
# Connect to a remote NethSecurity controller
#

UCI_CONF="ns-plug"
CONFIG_FILE="/usr/share/ns-plug/client.conf"

server=$(uci -q get ${UCI_CONF}.config.server)
system_id=$(uci -q get ${UCI_CONF}.config.system_id)

# Exit early if no server has been set
if [ -z "${server}" ]; then
    exit 1
fi

# If no system_id has been set, just use the mac address of lan device
if [ -z "${system_id}" ]; then
    system_id=$(ip -br -o link show dev $(uci -q get network.lan.device) | awk '{print $3}' | sed 's/://g')
fi

# No system_id, exit with error
if [ -z "${system_id}" ]; then
    exit 1
fi

# Create controller user if not exits
user=$(uci -q get rpcd.controller.username 2>/dev/null)
if [ -z "${user}" ]; then
    user=$(openssl rand -hex 12)
    uci set rpcd.controller=login
    uci set rpcd.controller.username=${user}
    uci add_list rpcd.controller.read='*'
    uci add_list rpcd.controller.write='*'
    uci commit
fi

# Generate random password at each restart
secret=$(date +%s$RANDOM | sha256sum | awk '{print $1}')
# Encrypt the password
passwd=$(uhttpd -m ${secret})

# Disable certificate verification if tls_verify is set to 0
curl_opts="-sL"
tls_verify=$(uci -q get ${UCI_CONF}.config.tls_verify)
if [ "${tls_verify}" == "0" ]; then
    curl_opts="${curl_opts}k"
fi

# Register the server
valid=0
max_attempts=30 # 60 seconds
watchdog=0
response=""
until [ "${valid}" -eq 1 ] || [ "${watchdog}" -ge "${max_attempts}" ]
do
    response=$(curl ${curl_opts} -H "Content-Type: application/json" ${server}/api/units/register -X POST --data '{"unit_name": "'${system_id}'", "username": "'${user}'", "password": "'${secret}'"}')
    http_code=$(echo ${response} | jq -r .code)
    if [ "${http_code}" == "409" ]; then
        # Duplicate entry, cleanup uci config
        uci delete rpcd.controller
        uci commit
        exit 4
    elif [ "${http_code}" == "403" ]; then
        sleep 10
    elif [ "${http_code}" == "200" ]; then
        valid=1
    else
        sleep 2 # wait for controller to be reacheable
	watchdog=$(( watchdog + 1 ))
    fi
done

if  [ "${watchdog}" -ge "${max_attempts}" ]; then
    exit 5
fi

# Save the new password after successfull registration
uci set rpcd.controller.password=${passwd}
uci commit

# Configuration received, setup the VPN
host=$(echo ${response} | jq -r .data.host)
port=$(echo ${response} | jq -r .data.port)
cert=$(echo ${response} | jq -r .data.cert)
key=$(echo ${response} | jq -r .data.key)
ca=$(echo ${response} | jq -r .data.ca)
cat <<EOF > ${CONFIG_FILE}
client
server-poll-timeout 5
nobind
float
explicit-exit-notify 1
remote ${host} ${port} udp
dev tun-nsplug
tls-client
<ca>
${ca}
</ca>
<cert>
${cert}
</cert>
<key>
${key}
</key>
auth-nocache
verb 3
EOF

# Configure rsyslog to send to promtail
if [ "$(uci -q get rsyslog.promtail)" == "" ]; then
    uci set rsyslog.promtail=forwarder
    uci set rsyslog.promtail.source=*.*
    uci set rsyslog.promtail.protocol=tcp
    uci set rsyslog.promtail.port=$(echo "$response" | jq -r .data.promtail_port)
    uci set rsyslog.promtail.rfc=5424
    uci set rsyslog.promtail.target=$(echo "$response" | jq -r .data.promtail_address)
    uci commit
    /etc/init.d/rsyslog restart
    sleep 5 # wait for rsyslog
fi

# Start the VPN
if [ -f ${CONFIG_FILE} ]; then
    exec openvpn ${CONFIG_FILE}
else
    exit 3
fi
